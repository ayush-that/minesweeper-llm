\documentclass[11pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[margin=1in]{geometry}
\usepackage{amsmath,amssymb}
\usepackage{graphicx}
\usepackage{booktabs}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{enumitem}
\usepackage{float}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},
    commentstyle=\color{codegreen},
    keywordstyle=\color{codepurple},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codegreen},
    basicstyle=\ttfamily\footnotesize,
    breaklines=true,
    captionpos=b,
    keepspaces=true,
    numbers=left,
    numbersep=5pt,
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    tabsize=2
}
\lstset{style=mystyle}

\title{\textbf{Minesweeper LLM Agent: Fine-Tuning Qwen2.5-14B-Instruct\\for Competitive Minesweeper Play}}
\author{Team 92}
\date{February 2026}

\begin{document}

\maketitle

\begin{abstract}
We present a fine-tuned Qwen2.5-14B-Instruct model that plays Minesweeper by outputting structured JSON actions given board states in a novel \emph{frontier format}. Our approach combines: (1)~a custom three-tier constraint satisfaction solver for high-quality training data, (2)~a novel prompt representation that converts spatial grids into coordinate-based constraints, (3)~supervised fine-tuning with LoRA on 37K curated examples, and (4)~GRPO reinforcement learning with three custom reward functions. Key findings: frontier format achieves 100\% valid move rate vs.\ 7--15\% for compact ASCII grids, and system prompt alignment between training and inference is the single most important factor. The model achieves +34.8 average score per game with 100\% valid JSON and 100\% valid moves across all board sizes up to 50$\times$50.
\end{abstract}

% ================================================================
\section{Introduction}
% ================================================================

Minesweeper is a constraint satisfaction problem where an agent must reveal safe cells and flag mines on a grid. In this competition, an LLM must output a single JSON action \texttt{\{"type":"reveal"|"flag","row":R,"col":C\}} per turn, scoring +15 for safe reveals, +15 for correct flags, $-25$ for mine hits, $-10$ for wrong flags, $-12$ for redundant moves, and +50 for winning. Boards range from $6\times6$ to $50\times50$ with 10--20\% mine density.

The core challenge is teaching an LLM to: (a)~parse spatial board information, (b)~perform constraint reasoning over numbered cells and their hidden neighbors, and (c)~output concise, valid JSON without verbose reasoning that would exceed the 128-token limit.

Our solution addresses all four competition pillars: \textbf{prompt engineering} (Section~\ref{sec:prompt}), \textbf{custom reward functions} (Section~\ref{sec:rewards}), \textbf{dataset curation} (Section~\ref{sec:data}), and \textbf{GRPO training} (Section~\ref{sec:grpo}).

% ================================================================
\section{LLM Prompt Engineering (Novel Design)}
\label{sec:prompt}
% ================================================================

We designed our prompt system \emph{entirely from scratch}, replacing the provided compact grid format with a novel \textbf{frontier format} representation.

\subsection{The Problem: LLMs Cannot Read Grids}

The default prompt represents the board as an ASCII grid:
\begin{lstlisting}
MINESWEEPER 8x8 MINES:10 FLAGS:2 LEFT:8
00001...
00012...
00001F..
\end{lstlisting}

We discovered that LLMs \textbf{fundamentally cannot reason spatially} about ASCII grids. The model cannot reliably determine which cells are adjacent to which numbers, leading to only 7--15\% valid moves (targeting cells that are actually hidden).

\subsection{Our Solution: Frontier Format}

We invented a \textbf{frontier format} that converts the spatial grid into an explicit constraint listing:

\begin{lstlisting}
MINESWEEPER 8x8 MINES:10 FLAGS:2 LEFT:8
FRONTIER (numbered cells with hidden neighbors):
R0C4=1 flags:0 hidden:[(0,5)(0,6)(1,5)]
R1C3=2 flags:1 hidden:[(0,5)(1,5)(2,5)]
HIDDEN NEAR NUMBERS: (0,5)(0,6)(1,5)(2,5)...
TOTAL HIDDEN: 52 INTERIOR(no adj number): 40
RULES: .=hidden F=flag 0-8=adjacent mines
- If number N has N flags around it, remaining hidden
  neighbors are SAFE->reveal
- If number N needs (N-flags) more mines and has exactly
  that many hidden neighbors, all are MINES->flag
- Flag certain mines FIRST, then reveal safe cells
- NEVER act on already revealed or flagged cells
- Choose ONLY from HIDDEN NEAR NUMBERS cells listed above
Output ONLY: {"type":"reveal"|"flag","row":R,"col":C}
\end{lstlisting}

This format:
\begin{itemize}
\item Explicitly lists each numbered cell's constraint: its value, flag count, and hidden neighbor coordinates
\item Provides a whitelist of valid target cells (\texttt{HIDDEN NEAR NUMBERS})
\item Embeds the constraint reasoning rules directly in the prompt
\item Caps frontier info at 200 entries and hidden cells at 100 to control token count
\end{itemize}

\begin{table}[H]
\centering
\caption{Impact of prompt format on model performance.}
\begin{tabular}{lccc}
\toprule
\textbf{Format} & \textbf{Valid Moves} & \textbf{Valid JSON} & \textbf{Avg Score} \\
\midrule
Compact Grid (provided) & 7--15\% & 85--95\% & $<0$ \\
Frontier (ours) & \textbf{100\%} & \textbf{100\%} & \textbf{+34.8} \\
\bottomrule
\end{tabular}
\end{table}

We set \texttt{FRONTIER\_THRESHOLD = 0}, meaning \emph{all} boards use frontier format, ensuring training and inference representations are identical.

\subsection{System Prompt Design}

We designed a concise system prompt optimized for structured output:

\begin{quote}
\texttt{"You are an expert Minesweeper AI. Analyze constraints and output ONLY a valid JSON action. No explanation."}
\end{quote}

\textbf{Critical finding}: The system prompt at inference must \emph{exactly match} the training prompt. We tested four configurations:

\begin{table}[H]
\centering
\caption{System prompt alignment impact (same model, different prompts).}
\begin{tabular}{llc}
\toprule
\textbf{Model} & \textbf{System Prompt} & \textbf{Avg Score/Game} \\
\midrule
v1 & Our training prompt (match) & \textbf{+34.8} \\
v1 & Tournament prompt (mismatch) & +17.2 \\
v2 & v2 training prompt (match) & +37.1 \\
v2 & Tournament prompt (mismatch) & +4.7 \\
\bottomrule
\end{tabular}
\end{table}

Mismatched prompts cause up to \textbf{7.4$\times$ performance degradation}. This was the single most impactful discovery in our project.

% ================================================================
\section{Custom Reward Functions and Strategy}
\label{sec:rewards}
% ================================================================

We designed \textbf{three custom reward functions} for GRPO training, each targeting a different aspect of Minesweeper play. These are combined with configurable weights.

\subsection{Reward Function 1: Format Compliance ($R_\text{format}$)}

Ensures the model outputs valid, parseable JSON:

\begin{equation}
R_\text{format}(\text{response}) = \begin{cases}
+1.0 & \text{if valid JSON with type, row, col fields} \\
-3.0 & \text{otherwise (heavy penalty for invalid output)}
\end{cases}
\end{equation}

The asymmetric penalty ($-3.0$ vs $+1.0$) strongly discourages format violations, which would cause immediate disqualification in the competition.

\subsection{Reward Function 2: Gameplay Outcome ($R_\text{game}$)}

Simulates the actual game scoring with a full Minesweeper engine:

\begin{equation}
R_\text{game}(\text{action}) = \frac{1}{25} \times \begin{cases}
+37.5 & \text{action wins the game (reveal/flag completes board)} \\
+15.0 & \text{correct flag on mine OR safe reveal (deducible)} \\
+10.0 & \text{safe reveal (non-deducible, lucky guess)} \\
-10.0 & \text{wrong flag OR over-flagging (flags} \geq \text{mines)} \\
-12.0 & \text{redundant (targeting revealed/flagged cell)} \\
-15.0 & \text{out of bounds} \\
-25.0 & \text{mine hit}
\end{cases}
\end{equation}

Each reward is normalized by dividing by 25 to keep gradients stable. The function reconstructs the full game state (mine positions, revealed cells, flagged cells) from dataset metadata and simulates the action's outcome.

\subsection{Reward Function 3: Strategic Quality ($R_\text{strat}$)}

Rewards strategic thinking beyond just outcome:

\begin{equation}
R_\text{strat} = \sum \begin{cases}
+0.20 & \text{if action targets cell adjacent to a number (frontier cell)} \\
+0.15 & \text{if correct deducible flag (logically certain mine)} \\
+0.15 & \text{if safe reveal opens a zero (cascading reveal)} \\
-0.30 & \text{if deducible move exists but model chose non-deducible} \\
-0.40 & \text{if flagging when already at mine count limit}
\end{cases}
\end{equation}

This reward encourages the model to:
\begin{itemize}
\item Prefer \textbf{deducible moves} (logically provable) over guesses ($-0.3$ penalty for ignoring available deductions)
\item Target \textbf{frontier cells} (adjacent to numbers) rather than interior cells ($+0.2$)
\item Flag only when \textbf{certain} ($+0.15$ for deducible flags, $-0.4$ for over-flagging)
\item Prefer reveals that \textbf{cascade} (revealing zeros opens multiple cells, $+0.15$)
\end{itemize}

\subsection{Combined Reward}

The three functions are combined with learned weights:
\begin{equation}
R_\text{total} = 1.0 \cdot R_\text{format} + 2.0 \cdot R_\text{game} + 0.5 \cdot R_\text{strat}
\end{equation}

Gameplay outcome is weighted highest ($2.0\times$) as it directly corresponds to competition scoring.

% ================================================================
\section{Dataset Curation}
\label{sec:data}
% ================================================================

\subsection{Three-Tier Constraint Satisfaction Solver}

We built a custom solver (\texttt{solver.py}, 700+ lines) implementing hierarchical Minesweeper constraint satisfaction:

\begin{description}[leftmargin=2cm]
\item[Tier 1 -- Propagation:] If numbered cell $N$ has $N$ flagged neighbors, remaining hidden neighbors are safe. If $N - F = |U|$, all hidden neighbors are mines. Covers $\sim$60--70\% of deterministic moves.

\item[Tier 2 -- Set-Based:] Coupled constraint analysis using subset reduction on paired cells sharing hidden neighbors. Covers $\sim$85--90\% combined.

\item[Tier 3 -- Tank Solver:] Backtracking enumeration over frontier components using Union-Find partitioning (35-cell component cap, 1s timeout). Computes per-cell mine probabilities weighted by:
\end{description}

\begin{equation}
\log w(m) = \text{lgamma}(Y+1) - \text{lgamma}(M-m+1) - \text{lgamma}(Y-M+m+1)
\end{equation}

where $Y$ = interior hidden cells, $M$ = remaining mines, $m$ = frontier mines. We use log-space (\texttt{lgamma}) instead of \texttt{math.comb} to avoid integer overflow on 50$\times$50 boards where $Y > 1000$.

\subsection{Board Size Distribution}

We curated training data across \textbf{13 board configurations}, including 7 square and 6 rectangular sizes to match the competition's ``NxM'' specification:

\begin{table}[H]
\centering
\caption{Training data distribution across board sizes (25K v2 dataset).}
\begin{tabular}{lccl}
\toprule
\textbf{Board Size} & \textbf{Games} & \textbf{Mine Density} & \textbf{Type} \\
\midrule
$6\times6$ & 1,000 & 10--20\% & Square (small) \\
$8\times8$ & 800 & 10--20\% & Square \\
$10\times10$ & 600 & 10--20\% & Square \\
$16\times16$ & 300 & 10--20\% & Square \\
$20\times20$ & 200 & 10--20\% & Square \\
$30\times30$ & 100 & 10--20\% & Square (large) \\
$50\times50$ & 80 & 10--20\% & Square (max) \\
\midrule
$8\times12$ & 300 & 10--20\% & Rectangular \\
$10\times16$ & 200 & 10--20\% & Rectangular \\
$12\times20$ & 150 & 10--20\% & Rectangular \\
$16\times30$ & 100 & 10--20\% & Rectangular \\
$20\times40$ & 60 & 10--20\% & Rectangular \\
$30\times50$ & 40 & 10--20\% & Rectangular \\
\bottomrule
\end{tabular}
\end{table}

\subsection{Data Quality Controls}

\begin{itemize}
\item \textbf{Stage-balanced subsampling}: Prevents late-game/endgame domination. Each game contributes examples from early, mid, and late stages proportionally.
\item \textbf{94\% deducibility rate}: The vast majority of training examples have logically provable actions (Tier 1--3), teaching the model real constraint reasoning rather than guessing.
\item \textbf{All frontier format}: Every example uses our novel frontier representation, ensuring zero train/inference mismatch.
\item \textbf{Mine density matching}: All boards use 10--20\% mine density, matching competition specification exactly.
\item \textbf{Multiprocessing generation}: 32 parallel workers generate 25K+ examples in $\sim$90 seconds.
\end{itemize}

% ================================================================
\section{Training Pipeline: SFT + GRPO}
\label{sec:grpo}
% ================================================================

\subsection{Phase 1: Supervised Fine-Tuning (SFT)}

We use LoRA (Low-Rank Adaptation) for parameter-efficient fine-tuning:

\begin{table}[H]
\centering
\caption{SFT hyperparameters.}
\begin{tabular}{ll}
\toprule
\textbf{Parameter} & \textbf{Value} \\
\midrule
LoRA rank ($r$) & 64 \\
LoRA alpha ($\alpha$) & 128 (scaling = $\alpha/r = 2.0$) \\
Target modules & q\_proj, k\_proj, v\_proj, o\_proj, gate\_proj, up\_proj, down\_proj \\
Trainable parameters & 275M / 15B (1.83\%) \\
Effective batch size & 16 (2 per device $\times$ 8 accumulation) \\
Learning rate & $2 \times 10^{-5}$ (cosine decay) \\
Epochs & 1 \\
Training steps & 2,298 \\
Max sequence length & 8,192 tokens \\
Precision & BF16 \\
Loss trajectory & 0.91 $\rightarrow$ 0.09 \\
\bottomrule
\end{tabular}
\end{table}

SFT establishes strong format compliance (100\% valid JSON) and basic constraint reasoning.

\subsection{Phase 2: GRPO Reinforcement Learning}

After SFT, we applied \textbf{Group Relative Policy Optimization (GRPO)} using TRL 0.23.0 with our three custom reward functions:

\begin{table}[H]
\centering
\caption{GRPO configuration.}
\begin{tabular}{ll}
\toprule
\textbf{Parameter} & \textbf{Value} \\
\midrule
Loss type & DAPO (Dynamic Advantage Policy Optimization) \\
Epsilon (clip range) & 0.2 (low) / 0.28 (high, asymmetric) \\
Beta (KL penalty) & 0.0 (no KL constraint) \\
Num generations per prompt & 4 \\
Max completion length & 128 tokens \\
Temperature & 1.0 (sampling for diversity) \\
Reward scaling & Batch-level normalization \\
Reward weights & [1.0, 2.0, 0.5] (format, gameplay, strategic) \\
Learning rate & $5 \times 10^{-6}$ \\
Training steps & 400 \\
Optimizer & AdamW 8-bit \\
\bottomrule
\end{tabular}
\end{table}

\subsection{GRPO Analysis and Lessons Learned}

GRPO produced mixed results. While the reward functions correctly scored model outputs, several factors limited GRPO's effectiveness:

\begin{enumerate}
\item \textbf{Insufficient generation diversity}: With only 4 generations per prompt (constrained by 14B model on 256GB VRAM; 8 generations caused OOM), reward variance was too low for meaningful policy gradients. \texttt{grad\_norm} $\approx 0$ for most steps.

\item \textbf{SFT already near-optimal}: The SFT model achieved $>$95\% correct actions, leaving minimal room for RL improvement. The model was already in a local optimum for format and basic reasoning.

\item \textbf{Performance degradation}: After 400 steps, average score decreased from +33.6 to $<$+25, suggesting GRPO was ``unlearning'' SFT knowledge faster than learning new strategies.
\end{enumerate}

\textbf{Key insight}: For structured output tasks with limited generation budget, SFT on high-quality solver-generated data outperforms GRPO. RL benefits require either (a)~many more generations per prompt ($\geq$16) for sufficient reward signal diversity, or (b)~a weaker SFT baseline with more room for improvement.

Our final submission uses the \textbf{SFT-only checkpoint} which scored +34.8 avg/game vs GRPO's $<$+25.

% ================================================================
\section{Continued SFT Experiments}
% ================================================================

We explored continued fine-tuning to improve specific weaknesses:

\begin{itemize}
\item \textbf{v2 (5K examples, different system prompt)}: Catastrophic forgetting. Score dropped to +4.7 when evaluated with the new prompt, proving system prompt changes during continued SFT are destructive.

\item \textbf{v3 (2.9K targeted examples, same prompt)}: Improved 50$\times$50 performance (+60 vs $-$10) but regressed on medium boards ($10\times10$: +16.7 vs +42.0). Net worse overall (+27.4 vs +34.8).

\item \textbf{Lesson}: The original v1 model trained on the full 37K dataset remains the most robust. Continued SFT on subsets causes forgetting of the broader distribution.
\end{itemize}

% ================================================================
\section{Results}
% ================================================================

\begin{table}[H]
\centering
\caption{Final model (v1 SFT) performance across board sizes (66 games).}
\begin{tabular}{lcccccc}
\toprule
\textbf{Board} & \textbf{Games} & \textbf{Avg Score} & \textbf{Valid JSON} & \textbf{Valid Moves} & \textbf{Safe Reveals} & \textbf{Flag Acc.} \\
\midrule
$6\times6$ & 15 & +2.0 & 100\% & 100\% & 31 & 34\% \\
$8\times8$ & 15 & +32.0 & 100\% & 100\% & 38 & 63\% \\
$10\times10$ & 15 & +42.0 & 100\% & 100\% & 38 & 65\% \\
$16\times16$ & 8 & +23.1 & 100\% & 100\% & 10 & 57\% \\
$20\times20$ & 8 & +125.6 & 100\% & 100\% & 46 & 56\% \\
$30\times30$ & 3 & $-5.0$ & 100\% & 100\% & 4 & 40\% \\
$50\times50$ & 2 & $-10.0$ & 100\% & 100\% & 1 & 43\% \\
\midrule
\textbf{Overall} & \textbf{66} & \textbf{+34.8} & \textbf{100\%} & \textbf{100\%} & \textbf{168} & \textbf{56\%} \\
\bottomrule
\end{tabular}
\end{table}

Key metrics: 100\% valid JSON, 100\% valid moves, 0\% verbose output ($\sim$20 tokens per response), +34.8 avg score/game, no recursion risk.

% ================================================================
\section{Competition Compliance}
% ================================================================

\begin{itemize}
\item[$\checkmark$] Base model: Qwen/Qwen2.5-14B-Instruct (approved list)
\item[$\checkmark$] Model at \texttt{/workspace/your\_finetuned\_model} (28GB merged)
\item[$\checkmark$] \texttt{max\_new\_tokens: 128} in config
\item[$\checkmark$] No post-LLM processing (\texttt{SAFETY\_NET\_ENABLED = False})
\item[$\checkmark$] No internet or third-party calls during inference
\item[$\checkmark$] Concise JSON output ($\sim$20 tokens, well under 128 limit)
\item[$\checkmark$] Handles boards up to $50\times50$ with 10--20\% mines
\item[$\checkmark$] Base model copied to \texttt{/workspace} before training
\end{itemize}

\end{document}
